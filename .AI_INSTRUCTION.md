# AI Instruction

This file contains core AI guidance that applies across all AI-assisted development in this repository. Both `CLAUDE.md` and `.specify/memory/constitution.md` reference this file.

## Project Overview

Scribel is a desktop application for rapid note capture and AI-powered knowledge management, combining quick-jot workflows with agentic AI capabilities. Built as a Tauri + React application, it operates on local markdown files (Obsidian-compatible) with SQLite for jot storage and vector search.

**Core Philosophy:** "Jot first, organize later" — capture thoughts instantly, let AI help connect and structure them over time.

## Critical Performance Targets

These are non-negotiable thresholds that define the user experience:

| Metric | Target |
|--------|--------|
| Cold start to first jot | <500ms |
| Jot creation latency | <50ms |
| Global hotkey response | <200ms |
| Semantic search query | <500ms |
| AI suggestions after jot | <1 second |

## Core Principles

### 1. Performance-First Architecture

Every feature MUST meet strict performance targets before being considered complete.

**Implementation Requirements:**
- Use SQLite WAL mode for concurrent access without blocking
- Async Tauri commands to prevent UI blocking
- Debounced search operations (500ms)
- Lazy loading and virtualized scrolling for large datasets
- Content hash checking to avoid unnecessary re-embedding

### 2. Local-First & Privacy by Design

User data MUST remain under user control with privacy as the default:

- All markdown files remain local (never uploaded)
- Only text content sent to AI services (for embeddings and queries)
- API keys stored in system keychain (macOS Keychain, Windows Credential Manager, Linux Secret Service)
- No telemetry or analytics without explicit user opt-in
- Support for local embedding models (Ollama) as alternative to API providers

**Implementation Requirements:**
- Use Tauri's fs API (sandboxed file access) instead of Node fs
- Never log or transmit vault file paths or complete file contents
- Make cloud features opt-in with clear disclosure

### 3. Obsidian Compatibility

Scribel MUST be a compatible layer on top of existing Obsidian vaults:

- Standard markdown with YAML frontmatter support
- `[[wiki-links]]` for internal linking (including `[[filename|display text]]` syntax)
- `#tags` in content
- Daily note format: `YYYY-MM-DD.md` in configurable folder
- Respect `.gitignore` and custom ignore patterns
- Never break Obsidian vault integrity

### 4. Crash Safety & Data Integrity (NON-NEGOTIABLE)

No data loss under any circumstances:

- SQLite with WAL (Write-Ahead Logging) mode mandatory
- Auto-save on every jot creation
- Undo stack for all AI write operations
- Atomic file operations (write to temp, then rename)
- All database operations use transactions
- Prepared statements for SQL queries (prevent injection)

## Technology Stack

| Layer | Technology |
|-------|------------|
| Frontend | React 18+, TypeScript, Tailwind CSS |
| Backend | Rust (Tauri 2.x), SQLite with sqlite-vec |
| AI | Anthropic Claude API |
| Embeddings | OpenAI API or Voyage AI (configurable) |
| Primary Platform | macOS 12+ |

### Dependency Constraints

- Prefer lightweight Rust crates to minimize binary size
- Avoid Node.js dependencies in Tauri backend (use Rust alternatives)
- Bundle size target: <50MB for macOS app bundle

## Data Schemas

### Jot Schema
```sql
CREATE TABLE jots (
  id INTEGER PRIMARY KEY,
  content TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  tags TEXT,  -- JSON array
  links TEXT, -- JSON array of [[wiki-links]]
  promoted BOOLEAN DEFAULT 0
);
```

### Embeddings Schema
```sql
CREATE VIRTUAL TABLE embeddings USING vec0(
  file_path TEXT PRIMARY KEY,
  embedding FLOAT[1536],  -- or 1024 for Voyage
  content_hash TEXT,
  updated_at INTEGER
);
```

## Testing Strategy

Features MUST be testable at three levels:

**Unit Tests:**
- Rust: Database operations, file parsing, embedding generation
- TypeScript: React components, hooks, utilities

**Integration Tests:**
- Tauri command invocation from frontend
- File watcher → embedding pipeline
- RAG retrieval accuracy (precision/recall)

**E2E Tests:**
- Jot creation → storage → retrieval
- Vault indexing → semantic search
- AI chat with tool use (mocked)

## AI Development Guidelines

When implementing with AI assistance:

1. **Never block the UI thread** — use async Tauri commands
2. **SQLite queries must use prepared statements** — avoid SQL injection
3. **File operations use Tauri's fs API** — not Node fs
4. **Respect user's vault structure** — never modify files without confirmation
5. **Token budget for Claude API** — aim for <100k tokens per request
6. **Test global hotkey on macOS first** — primary platform

---

## AI Development Teams

Scribel is developed by **five AI agent teams** working in parallel via git worktrees.

### Team Structure

| Team | Role | Implements Code? |
|------|------|------------------|
| **FE_DUDES** | Frontend Development Team | Yes |
| **BE_GEEKS** | Backend Development Team | Yes |
| **AI_GODS** | AI/ML Development Team | Yes |
| **THE_PO** | Product Owner | No — decisions only |
| **MASTER_TL** | Tech Lead | No — reviews only |

### Git Worktree Workflow

Each development team works in an **isolated branch** via git worktree.

#### Setup (One-Time)
```bash
# From main repository
git worktree add worktrees/frontend feature/epic-X-fY-fe-name
git worktree add worktrees/backend feature/epic-X-fY-be-name
git worktree add worktrees/ai feature/epic-X-fY-ai-name
```

#### Branch Naming Convention
```
feature/<epic-id>-<feature-id>-<team>-<short-name>

# Examples:
feature/epic-1-f1-fe-jot-input      # FE_DUDES
feature/epic-1-f2-be-jot-storage    # BE_GEEKS
feature/epic-3-f4-ai-rag-pipeline   # AI_GODS
```

#### Merge Rules
- **Teams NEVER merge directly**
- Merges are coordinated by **THE_PO** and executed by the **human**
- Teams push to their branches and create handoff documents when ready

### Team File Ownership

| Team | Owns | Does NOT Touch |
|------|------|----------------|
| **FE_DUDES** | `src/**/*`, `package.json`, `tsconfig.json` | `src-tauri/**/*` |
| **BE_GEEKS** | `src-tauri/**/*`, `Cargo.toml` | `src/**/*` |
| **AI_GODS** | `src-tauri/src/ai/**/*` | Core frontend/backend |
| **THE_PO** | Product decisions | Any code |
| **MASTER_TL** | Technical reviews | Any code |

### Communication Protocol

Teams communicate via **two mechanisms**:

#### 1. Handoff Documents

**Location**: `work/handoffs/`

**Filename format**: `<epic-id>-<feature-id>-<from>-to-<to>.md`

**Examples**:
- `epic-1-f1-FE_DUDES-to-BE_GEEKS.md`
- `epic-1-f2-BE_GEEKS-to-THE_PO.md`
- `epic-3-f4-MASTER_TL-to-AI_GODS.md`

**When to create handoffs**:
- Completing a feature or component
- Needing input from another team
- Blocking on another team's work
- Ready for integration/merge
- Escalating a decision

#### 2. Code Comments

**Format**: `// AI-DEV-NOTE: @<TEAM> - <message> -- by @<AUTHOR>`

**Examples**:
```typescript
// AI-DEV-NOTE: @BE_GEEKS - We expect this response shape from list_jots -- by @FE_DUDES
// AI-DEV-NOTE: @FE_DUDES - Command ready, call invoke('create_jot', {...}) -- by @BE_GEEKS
// AI-DEV-NOTE: @AI_GODS - Need streaming for chat responses -- by @FE_DUDES
// AI-DEV-NOTE: @THE_PO - Confirm this UX flow matches requirements -- by @FE_DUDES
// AI-DEV-NOTE: @MASTER_TL - Is this the right error handling pattern? -- by @BE_GEEKS
```

### Decision Escalation

| Topic | Escalate To |
|-------|-------------|
| Feature scope, UX, product direction | **THE_PO** |
| Architecture, patterns, performance | **MASTER_TL** |
| Both product and technical | **THE_PO** first, then **MASTER_TL** |

### Workflow Summary

```
1. Team receives task (from plan/tasks.md or handoff)
2. Team creates worktree branch
3. Team implements, leaving AI-DEV-NOTE comments
4. Team creates handoff when done or blocked
5. THE_PO reviews and coordinates merge with human
6. Human executes merge
7. All teams pull updated main
```

### Launch Commands

**FE_DUDES (Frontend Team)**:
```bash
cd worktrees/frontend
claude
# "I am FE_DUDES. Check work/handoffs/ and implement frontend tasks."
```

**BE_GEEKS (Backend Team)**:
```bash
cd worktrees/backend
claude
# "I am BE_GEEKS. Check work/handoffs/ and implement backend tasks."
```

**AI_GODS (AI Team)**:
```bash
cd worktrees/ai
claude
# "I am AI_GODS. Check work/handoffs/ and implement AI features."
```

### Full Workflow Details
See `work/WORKFLOW.md` for:
- Complete setup instructions
- File ownership rules
- Testing in parallel
- Communication patterns
- Troubleshooting guide

---

## Epic/Feature Structure

Features are organized hierarchically: **Epic > Feature > User Story**

### Epics (Major Milestones)

| Epic | Name | Description |
|------|------|-------------|
| epic-1 | Foundation | Project scaffold, jot storage, basic UI |
| epic-2 | Vault Integration | File watcher, daily note sync, settings |
| epic-3 | Intelligence | Embeddings, vector search, RAG chat, AI suggestions |
| epic-4 | Agentic Capabilities | AI file operations, jot promotion |
| epic-5 | Polish | Autocomplete, performance, onboarding |
| epic-6 | Advanced | MCP, multi-vault (future) |

### Feature Naming Convention

- Format: `epic-N/feature-M-short-name`
- Example: `epic-1/feature-1-project-scaffold`
- Use PRD feature codes (F1-F11) in feature descriptions for traceability
- Folder structure: `plan/epic-N-name/`

### Speckit Workflow

Each feature should have:
- `spec.md` — Requirements and acceptance criteria
- `plan.md` — Implementation design
- `tasks.md` — Actionable implementation tasks

---

## Documentation Structure

### Specifications & Planning
| Document | Location | Purpose |
|----------|----------|---------|
| PRD | `PRD.md` | Product Requirements Document — features, user flows, success metrics |
| Tech Design | `TECH_DESIGN.md` | Technical architecture and design decisions |
| Constitution | `.specify/memory/constitution.md` | Non-negotiable principles and governance |
| Epic Plans | `plan/` | Epic and feature planning documents |
| Feature Specs | `specs/` | Speckit-generated feature specifications |

### Plan Directory Structure
```
plan/
├── epics.md                    # Master epic list with status
├── epic-1-foundation/          # Epic 1 features
├── epic-2-vault-integration/   # Epic 2 features
├── epic-3-intelligence/        # Epic 3 features
├── epic-4-agentic/             # Epic 4 features
├── epic-5-polish/              # Epic 5 features
└── epic-6-advanced/            # Epic 6 features (future)
```

### Specs Directory Structure
```
specs/
└── [feature-name]/
    ├── spec.md                 # Feature specification
    ├── plan.md                 # Implementation plan
    └── tasks.md                # Actionable tasks
```

---

**Related Documents:**
- `CLAUDE.md` — Claude Code runtime guidance and implementation details
- `.specify/memory/constitution.md` — Project constitution with governance and amendment procedures
