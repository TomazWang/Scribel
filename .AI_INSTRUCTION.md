# AI Instruction

This file contains core AI guidance that applies across all AI-assisted development in this repository. Both `CLAUDE.md` and `.specify/memory/constitution.md` reference this file.

## Project Overview

Scribel is a desktop application for rapid note capture and AI-powered knowledge management, combining quick-jot workflows with agentic AI capabilities. Built as a Tauri + React application, it operates on local markdown files (Obsidian-compatible) with SQLite for jot storage and vector search.

**Core Philosophy:** "Jot first, organize later" — capture thoughts instantly, let AI help connect and structure them over time.

## Critical Performance Targets

These are non-negotiable thresholds that define the user experience:

| Metric | Target |
|--------|--------|
| Cold start to first jot | <500ms |
| Jot creation latency | <50ms |
| Global hotkey response | <200ms |
| Semantic search query | <500ms |
| AI suggestions after jot | <1 second |

## Core Principles

### 1. Performance-First Architecture

Every feature MUST meet strict performance targets before being considered complete.

**Implementation Requirements:**
- Use SQLite WAL mode for concurrent access without blocking
- Async Tauri commands to prevent UI blocking
- Debounced search operations (500ms)
- Lazy loading and virtualized scrolling for large datasets
- Content hash checking to avoid unnecessary re-embedding

### 2. Local-First & Privacy by Design

User data MUST remain under user control with privacy as the default:

- All markdown files remain local (never uploaded)
- Only text content sent to AI services (for embeddings and queries)
- API keys stored in system keychain (macOS Keychain, Windows Credential Manager, Linux Secret Service)
- No telemetry or analytics without explicit user opt-in
- Support for local embedding models (Ollama) as alternative to API providers

**Implementation Requirements:**
- Use Tauri's fs API (sandboxed file access) instead of Node fs
- Never log or transmit vault file paths or complete file contents
- Make cloud features opt-in with clear disclosure

### 3. Obsidian Compatibility

Scribel MUST be a compatible layer on top of existing Obsidian vaults:

- Standard markdown with YAML frontmatter support
- `[[wiki-links]]` for internal linking (including `[[filename|display text]]` syntax)
- `#tags` in content
- Daily note format: `YYYY-MM-DD.md` in configurable folder
- Respect `.gitignore` and custom ignore patterns
- Never break Obsidian vault integrity

### 4. Crash Safety & Data Integrity (NON-NEGOTIABLE)

No data loss under any circumstances:

- SQLite with WAL (Write-Ahead Logging) mode mandatory
- Auto-save on every jot creation
- Undo stack for all AI write operations
- Atomic file operations (write to temp, then rename)
- All database operations use transactions
- Prepared statements for SQL queries (prevent injection)

## Technology Stack

| Layer | Technology |
|-------|------------|
| Frontend | React 18+, TypeScript, Tailwind CSS |
| Backend | Rust (Tauri 2.x), SQLite with sqlite-vec |
| AI | Anthropic Claude API |
| Embeddings | OpenAI API or Voyage AI (configurable) |
| Primary Platform | macOS 12+ |

### Dependency Constraints

- Prefer lightweight Rust crates to minimize binary size
- Avoid Node.js dependencies in Tauri backend (use Rust alternatives)
- Bundle size target: <50MB for macOS app bundle

## Data Schemas

### Jot Schema
```sql
CREATE TABLE jots (
  id INTEGER PRIMARY KEY,
  content TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  tags TEXT,  -- JSON array
  links TEXT, -- JSON array of [[wiki-links]]
  promoted BOOLEAN DEFAULT 0
);
```

### Embeddings Schema
```sql
CREATE VIRTUAL TABLE embeddings USING vec0(
  file_path TEXT PRIMARY KEY,
  embedding FLOAT[1536],  -- or 1024 for Voyage
  content_hash TEXT,
  updated_at INTEGER
);
```

## Testing Strategy

Features MUST be testable at three levels:

**Unit Tests:**
- Rust: Database operations, file parsing, embedding generation
- TypeScript: React components, hooks, utilities

**Integration Tests:**
- Tauri command invocation from frontend
- File watcher → embedding pipeline
- RAG retrieval accuracy (precision/recall)

**E2E Tests:**
- Jot creation → storage → retrieval
- Vault indexing → semantic search
- AI chat with tool use (mocked)

## AI Development Guidelines

When implementing with AI assistance:

1. **Never block the UI thread** — use async Tauri commands
2. **SQLite queries must use prepared statements** — avoid SQL injection
3. **File operations use Tauri's fs API** — not Node fs
4. **Respect user's vault structure** — never modify files without confirmation
5. **Token budget for Claude API** — aim for <100k tokens per request
6. **Test global hotkey on macOS first** — primary platform

---

## Epic/Feature Structure

Features are organized hierarchically: **Epic > Feature > User Story**

### Epics (Major Milestones)

| Epic | Name | Description |
|------|------|-------------|
| epic-1 | Foundation | Project scaffold, jot storage, basic UI |
| epic-2 | Vault Integration | File watcher, daily note sync, settings |
| epic-3 | Intelligence | Embeddings, vector search, RAG chat, AI suggestions |
| epic-4 | Agentic Capabilities | AI file operations, jot promotion |
| epic-5 | Polish | Autocomplete, performance, onboarding |
| epic-6 | Advanced | MCP, multi-vault (future) |

### Feature Naming Convention

- Format: `epic-N/feature-M-short-name`
- Example: `epic-1/feature-1-project-scaffold`
- Use PRD feature codes (F1-F11) in feature descriptions for traceability
- Folder structure: `plan/epic-N-name/`

### Speckit Workflow

Each feature should have:
- `spec.md` — Requirements and acceptance criteria
- `plan.md` — Implementation design
- `tasks.md` — Actionable implementation tasks

---

## Documentation Structure

### Specifications & Planning
| Document | Location | Purpose |
|----------|----------|---------|
| PRD | `PRD.md` | Product Requirements Document — features, user flows, success metrics |
| Tech Design | `TECH_DESIGN.md` | Technical architecture and design decisions |
| Constitution | `.specify/memory/constitution.md` | Non-negotiable principles and governance |
| Epic Plans | `plan/` | Epic and feature planning documents |
| Feature Specs | `specs/` | Speckit-generated feature specifications |

### Plan Directory Structure
```
plan/
├── epics.md                    # Master epic list with status
├── epic-1-foundation/          # Epic 1 features
├── epic-2-vault-integration/   # Epic 2 features
├── epic-3-intelligence/        # Epic 3 features
├── epic-4-agentic/             # Epic 4 features
├── epic-5-polish/              # Epic 5 features
└── epic-6-advanced/            # Epic 6 features (future)
```

### Specs Directory Structure
```
specs/
└── [feature-name]/
    ├── spec.md                 # Feature specification
    ├── plan.md                 # Implementation plan
    └── tasks.md                # Actionable tasks
```

---

**Related Documents:**
- `CLAUDE.md` — Claude Code runtime guidance and implementation details
- `.specify/memory/constitution.md` — Project constitution with governance and amendment procedures
